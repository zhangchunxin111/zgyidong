/*!

 * Bootstrap v3.3.5 (http://getbootstrap.com)

 * Copyright 2011-2015 Twitter, Inc.

 * Licensed under the MIT license

 */
 var mbz = "";
 
  var ifhasbd = $("body").css("background-image").indexOf("url"); 
 //初始化第一张图背景色
 if(ifhasbd < 0){
     var firstbkcolor = $("#lbtframe div:eq(0) a").attr("data-bg-color");
	 if (firstbkcolor !== 'undefined' && firstbkcolor) {
		$('#slide_content').css('background-color',firstbkcolor);
	 }
 }

if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery"); +
function(a) {
    "use strict";
    var b = a.fn.jquery.split(" ")[0].split(".");
    if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")
} (jQuery),
+
function(a) {
    "use strict";
    function b() {
        var a = document.createElement("bootstrap"),
        b = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var c in b) if (void 0 !== a.style[c]) return {
            end: b[c]
        };
        return ! 1
    }
    a.fn.emulateTransitionEnd = function(b) {
        var c = !1,
        d = this;
        a(this).one("bsTransitionEnd",
        function() {
            c = !0
        });
        var e = function() {
            c || a(d).trigger(a.support.transition.end)
        };
        return setTimeout(e, b),
        this
    },
    a(function() {
        a.support.transition = b(),
        a.support.transition && (a.event.special.bsTransitionEnd = {
            bindType: a.support.transition.end,
            delegateType: a.support.transition.end,
            handle: function(b) {
                return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0
            }
        })
    })
} (jQuery),
+
function(a) {
    "use strict";
    function b(b) {
        return this.each(function() {
            var c = a(this),
            e = c.data("bs.alert");
            e || c.data("bs.alert", e = new d(this)),
            "string" == typeof b && e[b].call(c)
        })
    }
    var c = '[data-dismiss="alert"]',
    d = function(b) {
        a(b).on("click", c, this.close)
    };
    d.VERSION = "3.3.5",
    d.TRANSITION_DURATION = 150,
    d.prototype.close = function(b) {
        function c() {
            g.detach().trigger("closed.bs.alert").remove()
        }
        var e = a(this),
        f = e.attr("data-target");
        f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\s]*$)/, ""));
        var g = a(f);
        b && b.preventDefault(),
        g.length || (g = e.closest(".alert")),
        g.trigger(b = a.Event("close.bs.alert")),
        b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c())
    };
    var e = a.fn.alert;
    a.fn.alert = b,
    a.fn.alert.Constructor = d,
    a.fn.alert.noConflict = function() {
        return a.fn.alert = e,
        this
    },
    a(document).on("click.bs.alert.data-api", c, d.prototype.close)
} (jQuery),
+
function(a) {
    "use strict";
    function b(b) {
        return this.each(function() {
            var d = a(this),
            e = d.data("bs.button"),
            f = "object" == typeof b && b;
            e || d.data("bs.button", e = new c(this, f)),
            "toggle" == b ? e.toggle() : b && e.setState(b)
        })
    }
    var c = function(b, d) {
        this.$element = a(b),
        this.options = a.extend({},
        c.DEFAULTS, d),
        this.isLoading = !1
    };
    c.VERSION = "3.3.5",
    c.DEFAULTS = {
        loadingText: "loading..."
    },
    c.prototype.setState = function(b) {
        var c = "disabled",
        d = this.$element,
        e = d.is("input") ? "val": "html",
        f = d.data();
        b += "Text",
        null == f.resetText && d.data("resetText", d[e]()),
        setTimeout(a.proxy(function() {
            d[e](null == f[b] ? this.options[b] : f[b]),
            "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c))
        },
        this), 0)
    },
    c.prototype.toggle = function() {
        var a = !0,
        b = this.$element.closest('[data-toggle="buttons"]');
        if (b.length) {
            var c = this.$element.find("input");
            "radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")),
            c.prop("checked", this.$element.hasClass("active")),
            a && c.trigger("change")
        } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")),
        this.$element.toggleClass("active")
    };
    var d = a.fn.button;
    a.fn.button = b,
    a.fn.button.Constructor = c,
    a.fn.button.noConflict = function() {
        return a.fn.button = d,
        this
    },
    a(document).on("click.bs.button.data-api", '[data-toggle^="button"]',
    function(c) {
        var d = a(c.target);
        d.hasClass("btn") || (d = d.closest(".btn")),
        b.call(d, "toggle"),
        a(c.target).is('input[type="radio"]') || a(c.target).is('input[type="checkbox"]') || c.preventDefault()
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]',
    function(b) {
        a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type))
    })
} (jQuery),
+
function(a) {
    "use strict";
    function b(b) {
        return this.each(function() {
            var d = a(this),
            e = d.data("bs.carousel"),
            f = a.extend({},
            c.DEFAULTS, d.data(), "object" == typeof b && b),
            g = "string" == typeof b ? b: f.slide;
            e || d.data("bs.carousel", e = new c(this, f)),
            "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle()
        })
    }
    var c = function(b, c) {
        this.$element = a(b),
        this.$indicators = this.$element.find(".carousel-indicators"),
        this.options = c,
        this.paused = null,
        this.sliding = null,
        this.interval = null,
        this.$active = null,
        this.$items = null,
        this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)),
        "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this))
    };
    c.VERSION = "3.3.5",
    c.TRANSITION_DURATION = 600,
    c.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    },
    c.prototype.keydown = function(a) {
        if (!/input|textarea/i.test(a.target.tagName)) {
            switch (a.which) {
            case 37:
                this.prev();
                break;
            case 39:
                this.next();
                break;
            default:
                return
            }
            a.preventDefault()
        }
    },
    c.prototype.cycle = function(b) {
        return b || (this.paused = !1),
        this.interval && clearInterval(this.interval),
        this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)),
        this
    },
    c.prototype.getItemIndex = function(a) {
        return this.$items = a.parent().children(".item"),
        this.$items.index(a || this.$active)
    },
    c.prototype.getItemForDirection = function(a, b) {
        var c = this.getItemIndex(b),
        d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1; 
        if (d && !this.options.wrap) return b;
        var e = "prev" == a ? -1 : 1,
        f = (c + e) % this.$items.length;
        return this.$items.eq(f)
    },
    c.prototype.to = function(a) { 	
        var b = this,
        c = this.getItemIndex(this.$active = this.$element.find(".item.active"));
		mbz = a;
        return a > this.$items.length - 1 || 0 > a ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel",
        function() {
            b.to(a)
        }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next": "prev", this.$items.eq(a))
    },
    c.prototype.pause = function(b) {
        return b || (this.paused = !0),
        this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)),
        this.interval = clearInterval(this.interval),
        this
    },
    c.prototype.next = function() {
        return this.sliding ? void 0 : this.slide("next")
    },
    c.prototype.prev = function() {
        return this.sliding ? void 0 : this.slide("prev")
    },
    c.prototype.slide = function(b, d) { 
        var e = this.$element.find(".item.active"),
        f = d || this.getItemForDirection(b, e),
        g = this.interval,
        h = "next" == b ? "left": "right",
        i = this; 
		//处理背景图
		var gd_bkcolor = document.getElementById("slide_content");
		var gd_frmae = document.getElementById("lbtframe");
		var gd_frmae_len = gd_frmae.getElementsByTagName("div").length;
		var eind = e.index();  
		if(h == "right"){
		  eind = eind - 1;
		  if(eind < 0){
		    eind = gd_frmae_len - 1;
		  }
		}
		else if(h == "left"){
		  eind = eind + 1;
		  if(eind > (gd_frmae_len - 1)){
		    eind = 0;
		  }
		}
		if(ifhasbd < 0){ 
        if(mbz != ""){ 		
			/*switch(mbz){
			   case "0":gd_bkcolor.style.backgroundColor="#D8C3BE"; 
			   break;
			   case "1":gd_bkcolor.style.backgroundColor="#FFD102";
			   break;
			   case "2":gd_bkcolor.style.backgroundColor="#89DEFB"; 
			   break;
			   case "3":gd_bkcolor.style.backgroundColor="#D12D12";
			   break;
			   case "4":gd_bkcolor.style.backgroundColor="#1F71F8";
			   break;  
			   default:
			   break;
			}*/
			var bgColor = $("#lbtframe div:eq(" + mbz + ") a").attr("data-bg-color");
			if (bgColor !== 'undefined' && bgColor) {
				gd_bkcolor.style.backgroundColor = bgColor;
			}
		}
		else{
			/*switch(eind){
			   case 0:gd_bkcolor.style.backgroundColor="#D8C3BE"; 
			   break;
			   case 1:gd_bkcolor.style.backgroundColor="#FFD102";
			   break;
			   case 2:gd_bkcolor.style.backgroundColor="#89DEFB"; 
			   break;
			   case 3:gd_bkcolor.style.backgroundColor="#D12D12";
			   break;
			   case 4:gd_bkcolor.style.backgroundColor="#1F71F8";
			   break;  
			   default:
			   break;
			}*/
			var bgColor = $("#lbtframe div:eq(" + eind + ") a").attr("data-bg-color");
			if (bgColor !== 'undefined' && bgColor) {
				gd_bkcolor.style.backgroundColor = bgColor;
			}
		}
		}
		mbz = "";
		//处理背景图结束
        if (f.hasClass("active")) return this.sliding = !1;
        var j = f[0],
        k = a.Event("slide.bs.carousel", {
            relatedTarget: j,
            direction: h
        }); 
        if (this.$element.trigger(k), !k.isDefaultPrevented()) {
            if (this.sliding = !0, g && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var l = a(this.$indicators.children()[this.getItemIndex(f)]);
                l && l.addClass("active")
            }
            var m = a.Event("slid.bs.carousel", {
                relatedTarget: j,
                direction: h
            });
            return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd",
            function() {
                f.removeClass([b, h].join(" ")).addClass("active"),
                e.removeClass(["active", h].join(" ")),
                i.sliding = !1,
                setTimeout(function() {
                    i.$element.trigger(m)
                },
                0)
            }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)),
            g && this.cycle(),
            this
        }
    };
    var d = a.fn.carousel;
    a.fn.carousel = b,
    a.fn.carousel.Constructor = c,
    a.fn.carousel.noConflict = function() {
        return a.fn.carousel = d,
        this
    };
    var e = function(c) {
        var d, e = a(this),
        f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\s]+$)/, ""));
        if (f.hasClass("carousel")) {
            var g = a.extend({},
            f.data(), e.data()),
            h = e.attr("data-slide-to"); 
            h && (g.interval = !1),
            b.call(f, g),
            h && f.data("bs.carousel").to(h),
            c.preventDefault()
        }
    };
    a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e),
    a(window).on("load",
    function() {
        a('[data-ride="carousel"]').each(function() {
            var c = a(this);
            b.call(c, c.data())
        })
    })
} (jQuery),
+
function(a) {
    "use strict";
    function b(b) {
        var c, d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, "");
        return a(d)
    }
    function c(b) {
        return this.each(function() {
            var c = a(this),
            e = c.data("bs.collapse"),
            f = a.extend({},
            d.DEFAULTS, c.data(), "object" == typeof b && b); ! e && f.toggle && /show|hide/.test(b) && (f.toggle = !1),
            e || c.data("bs.collapse", e = new d(this, f)),
            "string" == typeof b && e[b]()
        })
    }
    var d = function(b, c) {
        this.$element = a(b),
        this.options = a.extend({},
        d.DEFAULTS, c),
        this.$trigger = a('[data-toggle="collapse"][href="#' + b.id + '"],[data-toggle="collapse"][data-target="#' + b.id + '"]'),
        this.transitioning = null,
        this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger),
        this.options.toggle && this.toggle()
    };
    d.VERSION = "3.3.5",
    d.TRANSITION_DURATION = 350,
    d.DEFAULTS = {
        toggle: !0
    },
    d.prototype.dimension = function() {
        var a = this.$element.hasClass("width");
        return a ? "width": "height"
    },
    d.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var b, e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (! (e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) {
                var f = a.Event("show.bs.collapse");
                if (this.$element.trigger(f), !f.isDefaultPrevented()) {
                    e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null));
                    var g = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0),
                    this.$trigger.removeClass("collapsed").attr("aria-expanded", !0),
                    this.transitioning = 1;
                    var h = function() {
                        this.$element.removeClass("collapsing").addClass("collapse in")[g](""),
                        this.transitioning = 0,
                        this.$element.trigger("shown.bs.collapse")
                    };
                    if (!a.support.transition) return h.call(this);
                    var i = a.camelCase(["scroll", g].join("-"));
                    this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])
                }
            }
        }
    },
    d.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var b = a.Event("hide.bs.collapse");
            if (this.$element.trigger(b), !b.isDefaultPrevented()) {
                var c = this.dimension();
                this.$element[c](this.$element[c]())[0].offsetHeight,
                this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1),
                this.$trigger.addClass("collapsed").attr("aria-expanded", !1),
                this.transitioning = 1;
                var e = function() {
                    this.transitioning = 0,
                    this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
                };
                return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this)
            }
        }
    },
    d.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide": "show"]()
    },
    d.prototype.getParent = function() {
        return a(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(a.proxy(function(c, d) {
            var e = a(d);
            this.addAriaAndCollapsedClass(b(e), e)
        },
        this)).end()
    },
    d.prototype.addAriaAndCollapsedClass = function(a, b) {
        var c = a.hasClass("in");
        a.attr("aria-expanded", c),
        b.toggleClass("collapsed", !c).attr("aria-expanded", c)
    };
    var e = a.fn.collapse;
    a.fn.collapse = c,
    a.fn.collapse.Constructor = d,
    a.fn.collapse.noConflict = function() {
        return a.fn.collapse = e,
        this
    },
    a(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]',
    function(d) {
        var e = a(this);
        e.attr("data-target") || d.preventDefault();
        var f = b(e),
        g = f.data("bs.collapse"),
        h = g ? "toggle": e.data();
        c.call(f, h)
    })
} (jQuery),
+
function(a) {
    "use strict";
    function b(b) {
        var c = b.attr("data-target");
        c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, ""));
        var d = c && a(c);
        return d && d.length ? d: b.parent()
    }
    function c(c) {
        c && 3 === c.which || (a(e).remove(), a(f).each(function() {
            var d = a(this),
            e = b(d),
            f = {
                relatedTarget: this
            };
            e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger("hidden.bs.dropdown", f))))
        }))
    }
    function d(b) {
        return this.each(function() {
            var c = a(this),
            d = c.data("bs.dropdown");
            d || c.data("bs.dropdown", d = new g(this)),
            "string" == typeof b && d[b].call(c)
        })
    }
    var e = ".dropdown-backdrop",
    f = '[data-toggle="dropdown"]',
    g = function(b) {
        a(b).on("click.bs.dropdown", this.toggle)
    };
    g.VERSION = "3.3.5",
    g.prototype.toggle = function(d) {
        var e = a(this);
        if (!e.is(".disabled, :disabled")) {
            var f = b(e),
            g = f.hasClass("open");
            if (c(), !g) {
                "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);
                var h = {
                    relatedTarget: this
                };
                if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;
                e.trigger("focus").attr("aria-expanded", "true"),
                f.toggleClass("open").trigger("shown.bs.dropdown", h)
            }
            return ! 1
        }
    },
    g.prototype.keydown = function(c) {
        if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {
            var d = a(this);
            if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {
                var e = b(d),
                g = e.hasClass("open");
                if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"),
                d.trigger("click");
                var h = " li:not(.disabled):visible a",
                i = e.find(".dropdown-menu" + h);
                if (i.length) {
                    var j = i.index(c.target);
                    38 == c.which && j > 0 && j--,
                    40 == c.which && j < i.length - 1 && j++,
                    ~j || (j = 0),
                    i.eq(j).trigger("focus")
                }
            }
        }
    };
    var h = a.fn.dropdown;
    a.fn.dropdown = d,
    a.fn.dropdown.Constructor = g,
    a.fn.dropdown.noConflict = function() {
        return a.fn.dropdown = h,
        this
    },
    a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form",
    function(a) {
        a.stopPropagation()
    }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown)
} (jQuery),
+
function(a) {
    "use strict";
    function b(b, d) {
        return this.each(function() {
            var e = a(this),
            f = e.data("bs.modal"),
            g = a.extend({},
            c.DEFAULTS, e.data(), "object" == typeof b && b);
            f || e.data("bs.modal", f = new c(this, g)),
            "string" == typeof b ? f[b](d) : g.show && f.show(d)
        })
    }
    var c = function(b, c) {
        this.options = c,
        this.$body = a(document.body),
        this.$element = a(b),
        this.$dialog = this.$element.find(".modal-dialog"),
        this.$backdrop = null,
        this.isShown = null,
        this.originalBodyPad = null,
        this.scrollbarWidth = 0,
        this.ignoreBackdropClick = !1,
        this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function() {
            this.$element.trigger("loaded.bs.modal")
        },
        this))
    };
    c.VERSION = "3.3.5",
    c.TRANSITION_DURATION = 300,
    c.BACKDROP_TRANSITION_DURATION = 150,
    c.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    },
    c.prototype.toggle = function(a) {
        return this.isShown ? this.hide() : this.show(a)
    },
    c.prototype.show = function(b) {
        var d = this,
        e = a.Event("show.bs.modal", {
            relatedTarget: b
        });
        this.$element.trigger(e),
        this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal",
        function() {
            d.$element.one("mouseup.dismiss.bs.modal",
            function(b) {
                a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0)
            })
        }), this.backdrop(function() {
            var e = a.support.transition && d.$element.hasClass("fade");
            d.$element.parent().length || d.$element.appendTo(d.$body),
            d.$element.show().scrollTop(0),
            d.adjustDialog(),
            e && d.$element[0].offsetWidth,
            d.$element.addClass("in"),
            d.enforceFocus();
            var f = a.Event("shown.bs.modal", {
                relatedTarget: b
            });
            e ? d.$dialog.one("bsTransitionEnd",
            function() {
                d.$element.trigger("focus").trigger(f)
            }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f)
        }))
    },
    c.prototype.hide = function(b) {
        b && b.preventDefault(),
        b = a.Event("hide.bs.modal"),
        this.$element.trigger(b),
        this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal())
    },
    c.prototype.enforceFocus = function() {
        a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function(a) {
            this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus")
        },
        this))
    },
    c.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function(a) {
            27 == a.which && this.hide()
        },
        this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
    },
    c.prototype.resize = function() {
        this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal")
    },
    c.prototype.hideModal = function() {
        var a = this;
        this.$element.hide(),
        this.backdrop(function() {
            a.$body.removeClass("modal-open"),
            a.resetAdjustments(),
            a.resetScrollbar(),
            a.$element.trigger("hidden.bs.modal")
        })
    },
    c.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(),
        this.$backdrop = null
    },
    c.prototype.backdrop = function(b) {
        var d = this,
        e = this.$element.hasClass("fade") ? "fade": "";
        if (this.isShown && this.options.backdrop) {
            var f = a.support.transition && e;
            if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function(a) {
                return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = !1) : void(a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()))
            },
            this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;
            f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var g = function() {
                d.removeBackdrop(),
                b && b()
            };
            a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g()
        } else b && b()
    },
    c.prototype.handleUpdate = function() {
        this.adjustDialog()
    },
    c.prototype.adjustDialog = function() {
        var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth: "",
            paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth: ""
        })
    },
    c.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        })
    },
    c.prototype.checkScrollbar = function() {
        var a = window.innerWidth;
        if (!a) {
            var b = document.documentElement.getBoundingClientRect();
            a = b.right - Math.abs(b.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < a,
        this.scrollbarWidth = this.measureScrollbar()
    },
    c.prototype.setScrollbar = function() {
        var a = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "",
        this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth)
    },
    c.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad)
    },
    c.prototype.measureScrollbar = function() {
        var a = document.createElement("div");
        a.className = "modal-scrollbar-measure",
        this.$body.append(a);
        var b = a.offsetWidth - a.clientWidth;
        return this.$body[0].removeChild(a),
        b
    };
    var d = a.fn.modal;
    a.fn.modal = b,
    a.fn.modal.Constructor = c,
    a.fn.modal.noConflict = function() {
        return a.fn.modal = d,
        this
    },
    a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]',
    function(c) {
        var d = a(this),
        e = d.attr("href"),
        f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")),
        g = f.data("bs.modal") ? "toggle": a.extend({
            remote: !/#/.test(e) && e
        },
        f.data(), d.data());
        d.is("a") && c.preventDefault(),
        f.one("show.bs.modal",
        function(a) {
            a.isDefaultPrevented() || f.one("hidden.bs.modal",
            function() {
                d.is(":visible") && d.trigger("focus")
            })
        }),
        b.call(f, g, this)
    })
} (jQuery),
+
function(a) {
    "use strict";
    function b(b) {
        return this.each(function() {
            var d = a(this),
            e = d.data("bs.tooltip"),
            f = "object" == typeof b && b; (e || !/destroy|hide/.test(b)) && (e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]())
        })
    }
    var c = function(a, b) {
        this.type = null,
        this.options = null,
        this.enabled = null,
        this.timeout = null,
        this.hoverState = null,
        this.$element = null,
        this.inState = null,
        this.init("tooltip", a, b)
    };
    c.VERSION = "3.3.5",
    c.TRANSITION_DURATION = 150,
    c.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {
            selector: "body",
            padding: 0
        }
    },
    c.prototype.init = function(b, c, d) {
        if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = {
            click: !1,
            hover: !1,
            focus: !1
        },
        this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var e = this.options.trigger.split(" "), f = e.length; f--;) {
            var g = e[f];
            if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this));
            else if ("manual" != g) {
                var h = "hover" == g ? "mouseenter": "focusin",
                i = "hover" == g ? "mouseleave": "focusout";
                this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)),
                this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this))
            }
        }
        this.options.selector ? this._options = a.extend({},
        this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle()
    },
    c.prototype.getDefaults = function() {
        return c.DEFAULTS
    },
    c.prototype.getOptions = function(b) {
        return b = a.extend({},
        this.getDefaults(), this.$element.data(), b),
        b.delay && "number" == typeof b.delay && (b.delay = {
            show: b.delay,
            hide: b.delay
        }),
        b
    },
    c.prototype.getDelegateOptions = function() {
        var b = {},
        c = this.getDefaults();
        return this._options && a.each(this._options,
        function(a, d) {
            c[a] != d && (b[a] = d)
        }),
        b
    },
    c.prototype.enter = function(b) {
        var c = b instanceof this.constructor ? b: a(b.currentTarget).data("bs." + this.type);
        return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)),
        b instanceof a.Event && (c.inState["focusin" == b.type ? "focus": "hover"] = !0),
        c.tip().hasClass("in") || "in" == c.hoverState ? void(c.hoverState = "in") : (clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void(c.timeout = setTimeout(function() {
            "in" == c.hoverState && c.show()
        },
        c.options.delay.show)) : c.show())
    },
    c.prototype.isInStateTrue = function() {
        for (var a in this.inState) if (this.inState[a]) return ! 0;
        return ! 1
    },
    c.prototype.leave = function(b) {
        var c = b instanceof this.constructor ? b: a(b.currentTarget).data("bs." + this.type);
        return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)),
        b instanceof a.Event && (c.inState["focusout" == b.type ? "focus": "hover"] = !1),
        c.isInStateTrue() ? void 0 : (clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void(c.timeout = setTimeout(function() {
            "out" == c.hoverState && c.hide()
        },
        c.options.delay.hide)) : c.hide())
    },
    c.prototype.show = function() {
        var b = a.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(b);
            var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (b.isDefaultPrevented() || !d) return;
            var e = this,
            f = this.tip(),
            g = this.getUID(this.type);
            this.setContent(),
            f.attr("id", g),
            this.$element.attr("aria-describedby", g),
            this.options.animation && f.addClass("fade");
            var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement,
            i = /\s?auto?\s?/i,
            j = i.test(h);
            j && (h = h.replace(i, "") || "top"),
            f.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(h).data("bs." + this.type, this),
            this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element),
            this.$element.trigger("inserted.bs." + this.type);
            var k = this.getPosition(),
            l = f[0].offsetWidth,
            m = f[0].offsetHeight;
            if (j) {
                var n = h,
                o = this.getPosition(this.$viewport);
                h = "bottom" == h && k.bottom + m > o.bottom ? "top": "top" == h && k.top - m < o.top ? "bottom": "right" == h && k.right + l > o.width ? "left": "left" == h && k.left - l < o.left ? "right": h,
                f.removeClass(n).addClass(h)
            }
            var p = this.getCalculatedOffset(h, k, l, m);
            this.applyPlacement(p, h);
            var q = function() {
                var a = e.hoverState;
                e.$element.trigger("shown.bs." + e.type),
                e.hoverState = null,
                "out" == a && e.leave(e)
            };
            a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q()
        }
    },
    c.prototype.applyPlacement = function(b, c) {
        var d = this.tip(),
        e = d[0].offsetWidth,
        f = d[0].offsetHeight,
        g = parseInt(d.css("margin-top"), 10),
        h = parseInt(d.css("margin-left"), 10);
        isNaN(g) && (g = 0),
        isNaN(h) && (h = 0),
        b.top += g,
        b.left += h,
        a.offset.setOffset(d[0], a.extend({
            using: function(a) {
                d.css({
                    top: Math.round(a.top),
                    left: Math.round(a.left)
                })
            }
        },
        b), 0),
        d.addClass("in");
        var i = d[0].offsetWidth,
        j = d[0].offsetHeight;
        "top" == c && j != f && (b.top = b.top + f - j);
        var k = this.getViewportAdjustedDelta(c, b, i, j);
        k.left ? b.left += k.left: b.top += k.top;
        var l = /top|bottom/.test(c),
        m = l ? 2 * k.left - e + i: 2 * k.top - f + j,
        n = l ? "offsetWidth": "offsetHeight";
        d.offset(b),
        this.replaceArrow(m, d[0][n], l)
    },
    c.prototype.replaceArrow = function(a, b, c) {
        this.arrow().css(c ? "left": "top", 50 * (1 - a / b) + "%").css(c ? "top": "left", "")
    },
    c.prototype.setContent = function() {
        var a = this.tip(),
        b = this.getTitle();
        a.find(".tooltip-inner")[this.options.html ? "html": "text"](b),
        a.removeClass("fade in top bottom left right")
    },
    c.prototype.hide = function(b) {
        function d() {
            "in" != e.hoverState && f.detach(),
            e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type),
            b && b()
        }
        var e = this,
        f = a(this.$tip),
        g = a.Event("hide.bs." + this.type);
        return this.$element.trigger(g),
        g.isDefaultPrevented() ? void 0 : (f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this)
    },
    c.prototype.fixTitle = function() {
        var a = this.$element; (a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "")
    },
    c.prototype.hasContent = function() {
        return this.getTitle()
    },
    c.prototype.getPosition = function(b) {
        b = b || this.$element;
        var c = b[0],
        d = "BODY" == c.tagName,
        e = c.getBoundingClientRect();
        null == e.width && (e = a.extend({},
        e, {
            width: e.right - e.left,
            height: e.bottom - e.top
        }));
        var f = d ? {
            top: 0,
            left: 0
        }: b.offset(),
        g = {
            scroll: d ? document.documentElement.scrollTop || document.body.scrollTop: b.scrollTop()
        },
        h = d ? {
            width: a(window).width(),
            height: a(window).height()
        }: null;
        return a.extend({},
        e, g, h, f)
    },
    c.prototype.getCalculatedOffset = function(a, b, c, d) {
        return "bottom" == a ? {
            top: b.top + b.height,
            left: b.left + b.width / 2 - c / 2
        }: "top" == a ? {
            top: b.top - d,
            left: b.left + b.width / 2 - c / 2
        }: "left" == a ? {
            top: b.top + b.height / 2 - d / 2,
            left: b.left - c
        }: {
            top: b.top + b.height / 2 - d / 2,
            left: b.left + b.width
        }
    },
    c.prototype.getViewportAdjustedDelta = function(a, b, c, d) {
        var e = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return e;
        var f = this.options.viewport && this.options.viewport.padding || 0,
        g = this.getPosition(this.$viewport);
        if (/right|left/.test(a)) {
            var h = b.top - f - g.scroll,
            i = b.top + f - g.scroll + d;
            h < g.top ? e.top = g.top - h: i > g.top + g.height && (e.top = g.top + g.height - i)
        } else {
            var j = b.left - f,
            k = b.left + f + c;
            j < g.left ? e.left = g.left - j: k > g.right && (e.left = g.left + g.width - k)
        }
        return e
    },
    c.prototype.getTitle = function() {
        var a, b = this.$element,
        c = this.options;
        return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title)
    },
    c.prototype.getUID = function(a) {
        do a += ~~ (1e6 * Math.random());
        while (document.getElementById(a));
        return a
    },
    c.prototype.tip = function() {
        if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip
    },
    c.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    },
    c.prototype.enable = function() {
        this.enabled = !0
    },
    c.prototype.disable = function() {
        this.enabled = !1
    },
    c.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled
    },
    c.prototype.toggle = function(b) {
        var c = this;
        b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))),
        b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass("in") ? c.leave(c) : c.enter(c)
    },
    c.prototype.destroy = function() {
        var a = this;
        clearTimeout(this.timeout),
        this.hide(function() {
            a.$element.off("." + a.type).removeData("bs." + a.type),
            a.$tip && a.$tip.detach(),
            a.$tip = null,
            a.$arrow = null,
            a.$viewport = null
        })
    };
    var d = a.fn.tooltip;
    a.fn.tooltip = b,
    a.fn.tooltip.Constructor = c,
    a.fn.tooltip.noConflict = function() {
        return a.fn.tooltip = d,
        this
    }
} (jQuery),
+
function(a) {
    "use strict";
    function b(b) {
        return this.each(function() {
            var d = a(this),
            e = d.data("bs.popover"),
            f = "object" == typeof b && b; (e || !/destroy|hide/.test(b)) && (e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]())
        })
    }
    var c = function(a, b) {
        this.init("popover", a, b)
    };
    if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");
    c.VERSION = "3.3.5",
    c.DEFAULTS = a.extend({},
    a.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }),
    c.prototype = a.extend({},
    a.fn.tooltip.Constructor.prototype),
    c.prototype.constructor = c,
    c.prototype.getDefaults = function() {
        return c.DEFAULTS
    },
    c.prototype.setContent = function() {
        var a = this.tip(),
        b = this.getTitle(),
        c = this.getContent();
        a.find(".popover-title")[this.options.html ? "html": "text"](b),
        a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html": "append": "text"](c),
        a.removeClass("fade top bottom left right in"),
        a.find(".popover-title").html() || a.find(".popover-title").hide()
    },
    c.prototype.hasContent = function() {
        return this.getTitle() || this.getContent()
    },
    c.prototype.getContent = function() {
        var a = this.$element,
        b = this.options;
        return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content)
    },
    c.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow")
    };
    var d = a.fn.popover;
    a.fn.popover = b,
    a.fn.popover.Constructor = c,
    a.fn.popover.noConflict = function() {
        return a.fn.popover = d,
        this
    }
} (jQuery),
+
function(a) {
    "use strict";
    function b(c, d) {
        this.$body = a(document.body),
        this.$scrollElement = a(a(c).is(document.body) ? window: c),
        this.options = a.extend({},
        b.DEFAULTS, d),
        this.selector = (this.options.target || "") + " .nav li > a",
        this.offsets = [],
        this.targets = [],
        this.activeTarget = null,
        this.scrollHeight = 0,
        this.$scrollElement.on("scroll.bs.scrollspy", a.proxy(this.process, this)),
        this.refresh(),
        this.process()
    }
    function c(c) {
        return this.each(function() {
            var d = a(this),
            e = d.data("bs.scrollspy"),
            f = "object" == typeof c && c;
            e || d.data("bs.scrollspy", e = new b(this, f)),
            "string" == typeof c && e[c]()
        })
    }
    b.VERSION = "3.3.5",
    b.DEFAULTS = {
        offset: 10
    },
    b.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    },
    b.prototype.refresh = function() {
        var b = this,
        c = "offset",
        d = 0;
        this.offsets = [],
        this.targets = [],
        this.scrollHeight = this.getScrollHeight(),
        a.isWindow(this.$scrollElement[0]) || (c = "position", d = this.$scrollElement.scrollTop()),
        this.$body.find(this.selector).map(function() {
            var b = a(this),
            e = b.data("target") || b.attr("href"),
            f = /^#./.test(e) && a(e);
            return f && f.length && f.is(":visible") && [[f[c]().top + d, e]] || null
        }).sort(function(a, b) {
            return a[0] - b[0]
        }).each(function() {
            b.offsets.push(this[0]),
            b.targets.push(this[1])
        })
    },
    b.prototype.process = function() {
        var a, b = this.$scrollElement.scrollTop() + this.options.offset,
        c = this.getScrollHeight(),
        d = this.options.offset + c - this.$scrollElement.height(),
        e = this.offsets,
        f = this.targets,
        g = this.activeTarget;
        if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a);
        if (g && b < e[0]) return this.activeTarget = null,
        this.clear();
        for (a = e.length; a--;) g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a])
    },
    b.prototype.activate = function(b) {
        this.activeTarget = b,
        this.clear();
        var c = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]',
        d = a(c).parents("li").addClass("active");
        d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")),

        d.trigger("activate.bs.scrollspy")
    },
    b.prototype.clear = function() {
        a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active")
    };
    var d = a.fn.scrollspy;
    a.fn.scrollspy = c,
    a.fn.scrollspy.Constructor = b,
    a.fn.scrollspy.noConflict = function() {
        return a.fn.scrollspy = d,
        this
    },
    a(window).on("load.bs.scrollspy.data-api",
    function() {
        a('[data-spy="scroll"]').each(function() {
            var b = a(this);
            c.call(b, b.data())
        })
    })
} (jQuery),
+
function(a) {
    "use strict";
    function b(b) {
        return this.each(function() {
            var d = a(this),
            e = d.data("bs.tab");
            e || d.data("bs.tab", e = new c(this)),
            "string" == typeof b && e[b]()
        })
    }
    var c = function(b) {
        this.element = a(b)
    };
    c.VERSION = "3.3.5",
    c.TRANSITION_DURATION = 150,
    c.prototype.show = function() {
        var b = this.element,
        c = b.closest("ul:not(.dropdown-menu)"),
        d = b.data("target");
        if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
            var e = c.find(".active:last a"),
            f = a.Event("hide.bs.tab", {
                relatedTarget: b[0]
            }),
            g = a.Event("show.bs.tab", {
                relatedTarget: e[0]
            });
            if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {
                var h = a(d);
                this.activate(b.closest("li"), c),
                this.activate(h, h.parent(),
                function() {
                    e.trigger({
                        type: "hidden.bs.tab",
                        relatedTarget: b[0]
                    }),
                    b.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: e[0]
                    })
                })
            }
        }
    },
    c.prototype.activate = function(b, d, e) {
        function f() {
            g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1),
            b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0),
            h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"),
            b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0),
            e && e()
        }
        var g = d.find("> .active"),
        h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);
        g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(),
        g.removeClass("in")
    };
    var d = a.fn.tab;
    a.fn.tab = b,
    a.fn.tab.Constructor = c,
    a.fn.tab.noConflict = function() {
        return a.fn.tab = d,
        this
    };
    var e = function(c) {
        c.preventDefault(),
        b.call(a(this), "show")
    };
    a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e)
} (jQuery),
+
function(a) {
    "use strict";
    function b(b) {
        return this.each(function() {
            var d = a(this),
            e = d.data("bs.affix"),
            f = "object" == typeof b && b;
            e || d.data("bs.affix", e = new c(this, f)),
            "string" == typeof b && e[b]()
        })
    }
    var c = function(b, d) {
        this.options = a.extend({},
        c.DEFAULTS, d),
        this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)),
        this.$element = a(b),
        this.affixed = null,
        this.unpin = null,
        this.pinnedOffset = null,
        this.checkPosition()
    };
    c.VERSION = "3.3.5",
    c.RESET = "affix affix-top affix-bottom",
    c.DEFAULTS = {
        offset: 0,
        target: window
    },
    c.prototype.getState = function(a, b, c, d) {
        var e = this.$target.scrollTop(),
        f = this.$element.offset(),
        g = this.$target.height();
        if (null != c && "top" == this.affixed) return c > e ? "top": !1;
        if ("bottom" == this.affixed) return null != c ? e + this.unpin <= f.top ? !1 : "bottom": a - d >= e + g ? !1 : "bottom";
        var h = null == this.affixed,
        i = h ? e: f.top,
        j = h ? g: b;
        return null != c && c >= e ? "top": null != d && i + j >= a - d ? "bottom": !1
    },
    c.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(c.RESET).addClass("affix");
        var a = this.$target.scrollTop(),
        b = this.$element.offset();
        return this.pinnedOffset = b.top - a
    },
    c.prototype.checkPositionWithEventLoop = function() {
        setTimeout(a.proxy(this.checkPosition, this), 1)
    },
    c.prototype.checkPosition = function() {
        if (this.$element.is(":visible")) {
            var b = this.$element.height(),
            d = this.options.offset,
            e = d.top,
            f = d.bottom,
            g = Math.max(a(document).height(), a(document.body).height());
            "object" != typeof d && (f = e = d),
            "function" == typeof e && (e = d.top(this.$element)),
            "function" == typeof f && (f = d.bottom(this.$element));
            var h = this.getState(g, b, e, f);
            if (this.affixed != h) {
                null != this.unpin && this.$element.css("top", "");
                var i = "affix" + (h ? "-" + h: ""),
                j = a.Event(i + ".bs.affix");
                if (this.$element.trigger(j), j.isDefaultPrevented()) return;
                this.affixed = h,
                this.unpin = "bottom" == h ? this.getPinnedOffset() : null,
                this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix")
            }
            "bottom" == h && this.$element.offset({
                top: g - b - f
            })
        }
    };
    var d = a.fn.affix;
    a.fn.affix = b,
    a.fn.affix.Constructor = c,
    a.fn.affix.noConflict = function() {
        return a.fn.affix = d,
        this
    },
    a(window).on("load",
    function() {
        a('[data-spy="affix"]').each(function() {
            var c = a(this),
            d = c.data();
            d.offset = d.offset || {},
            null != d.offsetBottom && (d.offset.bottom = d.offsetBottom),
            null != d.offsetTop && (d.offset.top = d.offsetTop),
            b.call(c, d)
        })
    })
} (jQuery);

/*! Hammer.JS - v2.0.4 - 2014-09-28

 * http://hammerjs.github.io/

 *

 * Copyright (c) 2014 Jorik Tangelder;

 * Licensed under the MIT license */

(function(window, document, exportName, undefined) {

    'use strict';

    var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];

    var TEST_ELEMENT = document.createElement('div');

    var TYPE_FUNCTION = 'function';

    var round = Math.round;

    var abs = Math.abs;

    var now = Date.now;

    /**

     * set a timeout with a given scope

     * @param {Function} fn

     * @param {Number} timeout

     * @param {Object} context

     * @returns {number}

     */

    function setTimeoutContext(fn, timeout, context) {

        return setTimeout(bindFn(fn, context), timeout);

    }

    /**

     * if the argument is an array, we want to execute the fn on each entry

     * if it aint an array we don't want to do a thing.

     * this is used by all the methods that accept a single and array argument.

     * @param {*|Array} arg

     * @param {String} fn

     * @param {Object} [context]

     * @returns {Boolean}

     */

    function invokeArrayArg(arg, fn, context) {

        if (Array.isArray(arg)) {

            each(arg, context[fn], context);

            return true;

        }

        return false;

    }

    /**

     * walk objects and arrays

     * @param {Object} obj

     * @param {Function} iterator

     * @param {Object} context

     */

    function each(obj, iterator, context) {

        var i;

        if (!obj) {

            return;

        }

        if (obj.forEach) {

            obj.forEach(iterator, context);

        } else if (obj.length !== undefined) {

            i = 0;

            while (i < obj.length) {

                iterator.call(context, obj[i], i, obj);

                i++;

            }

        } else {

            for (i in obj) {

                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);

            }

        }

    }

    /**

     * extend object.

     * means that properties in dest will be overwritten by the ones in src.

     * @param {Object} dest

     * @param {Object} src

     * @param {Boolean} [merge]

     * @returns {Object} dest

     */

    function extend(dest, src, merge) {

        var keys = Object.keys(src);

        var i = 0;

        while (i < keys.length) {

            if (!merge || (merge && dest[keys[i]] === undefined)) {

                dest[keys[i]] = src[keys[i]];

            }

            i++;

        }

        return dest;

    }

    /**

     * merge the values from src in the dest.

     * means that properties that exist in dest will not be overwritten by src

     * @param {Object} dest

     * @param {Object} src

     * @returns {Object} dest

     */

    function merge(dest, src) {

        return extend(dest, src, true);

    }

    /**

     * simple class inheritance

     * @param {Function} child

     * @param {Function} base

     * @param {Object} [properties]

     */

    function inherit(child, base, properties) {

        var baseP = base.prototype,

        childP;

        //小马添加start---重写create方法
        var F = function() {

};

        F.prototype = baseP;

        childP = child.prototype = new F();

        //小马添加end
        // childP = child.prototype = Object.create(baseP);
        childP.constructor = child;

        childP._super = baseP;

        if (properties) {

            extend(childP, properties);

        }

    }

    /**

     * simple function bind

     * @param {Function} fn

     * @param {Object} context

     * @returns {Function}

     */

    function bindFn(fn, context) {

        return function boundFn() {

            return fn.apply(context, arguments);

        };

    }

    /**

     * let a boolean value also be a function that must return a boolean

     * this first item in args will be used as the context

     * @param {Boolean|Function} val

     * @param {Array} [args]

     * @returns {Boolean}

     */

    function boolOrFn(val, args) {

        if (typeof val == TYPE_FUNCTION) {

            return val.apply(args ? args[0] || undefined: undefined, args);

        }

        return val;

    }

    /**

     * use the val2 when val1 is undefined

     * @param {*} val1

     * @param {*} val2

     * @returns {*}

     */

    function ifUndefined(val1, val2) {

        return (val1 === undefined) ? val2: val1;

    }

    /**

     * addEventListener with multiple events at once

     * @param {EventTarget} target

     * @param {String} types

     * @param {Function} handler

     */

    function addEventListeners(target, types, handler) {

        each(splitStr(types),
        function(type) {

            target.addEventListener(type, handler, false);

        });

    }

    /**

     * removeEventListener with multiple events at once

     * @param {EventTarget} target

     * @param {String} types

     * @param {Function} handler

     */

    function removeEventListeners(target, types, handler) {

        each(splitStr(types),
        function(type) {

            target.removeEventListener(type, handler, false);

        });

    }

    /**

     * find if a node is in the given parent

     * @method hasParent

     * @param {HTMLElement} node

     * @param {HTMLElement} parent

     * @return {Boolean} found

     */

    function hasParent(node, parent) {

        while (node) {

            if (node == parent) {

                return true;

            }

            node = node.parentNode;

        }

        return false;

    }

    /**

     * small indexOf wrapper

     * @param {String} str

     * @param {String} find

     * @returns {Boolean} found

     */

    function inStr(str, find) {

        return str.indexOf(find) > -1;

    }

    /**

     * split string on whitespace

     * @param {String} str

     * @returns {Array} words

     */

    function splitStr(str) {

        return str.trim().split(/\s+/g);

    }

    /**

     * find if a array contains the object using indexOf or a simple polyFill

     * @param {Array} src

     * @param {String} find

     * @param {String} [findByKey]

     * @return {Boolean|Number} false when not found, or the index

     */

    function inArray(src, find, findByKey) {

        if (src.indexOf && !findByKey) {

            return src.indexOf(find);

        } else {

            var i = 0;

            while (i < src.length) {

                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {

                    return i;

                }

                i++;

            }

            return - 1;

        }

    }

    /**

     * convert array-like objects to real arrays

     * @param {Object} obj

     * @returns {Array}

     */

    function toArray(obj) {

        return Array.prototype.slice.call(obj, 0);

    }

    /**

     * unique array with objects based on a key (like 'id') or just by the array's value

     * @param {Array} src [{id:1},{id:2},{id:1}]

     * @param {String} [key]

     * @param {Boolean} [sort=False]

     * @returns {Array} [{id:1},{id:2}]

     */

    function uniqueArray(src, key, sort) {

        var results = [];

        var values = [];

        var i = 0;

        while (i < src.length) {

            var val = key ? src[i][key] : src[i];

            if (inArray(values, val) < 0) {

                results.push(src[i]);

            }

            values[i] = val;

            i++;

        }

        if (sort) {

            if (!key) {

                results = results.sort();

            } else {

                results = results.sort(function sortUniqueArray(a, b) {

                    return a[key] > b[key];

                });

            }

        }

        return results;

    }

    /**

     * get the prefixed property

     * @param {Object} obj

     * @param {String} property

     * @returns {String|Undefined} prefixed

     */

    function prefixed(obj, property) {

        var prefix, prop;

        var camelProp = property[0].toUpperCase() + property.slice(1);

        var i = 0;

        while (i < VENDOR_PREFIXES.length) {

            prefix = VENDOR_PREFIXES[i];

            prop = (prefix) ? prefix + camelProp: property;

            if (prop in obj) {

                return prop;

            }

            i++;

        }

        return undefined;

    }

    /**

     * get a unique id

     * @returns {number} uniqueId

     */

    var _uniqueId = 1;

    function uniqueId() {

        return _uniqueId++;

    }

    /**

     * get the window object of an element

     * @param {HTMLElement} element

     * @returns {DocumentView|Window}

     */

    function getWindowForElement(element) {

        var doc = element.ownerDocument;

        return (doc.defaultView || doc.parentWindow);

    }

    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

    var SUPPORT_TOUCH = ('ontouchstart' in window);

    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;

    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

    var INPUT_TYPE_TOUCH = 'touch';

    var INPUT_TYPE_PEN = 'pen';

    var INPUT_TYPE_MOUSE = 'mouse';

    var INPUT_TYPE_KINECT = 'kinect';

    var COMPUTE_INTERVAL = 25;

    var INPUT_START = 1;

    var INPUT_MOVE = 2;

    var INPUT_END = 4;

    var INPUT_CANCEL = 8;

    var DIRECTION_NONE = 1;

    var DIRECTION_LEFT = 2;

    var DIRECTION_RIGHT = 4;

    var DIRECTION_UP = 8;

    var DIRECTION_DOWN = 16;

    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;

    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;

    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

    var PROPS_XY = ['x', 'y'];

    var PROPS_CLIENT_XY = ['clientX', 'clientY'];

    /**

     * create new input type manager

     * @param {Manager} manager

     * @param {Function} callback

     * @returns {Input}

     * @constructor

     */

    function Input(manager, callback) {

        var self = this;

        this.manager = manager;

        this.callback = callback;

        this.element = manager.element;

        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {

            if (boolOrFn(manager.options.enable, [manager])) {

                self.handler(ev);

            }

        };

        this.init();

    }

    Input.prototype = {

        /**

         * should handle the inputEvent data and trigger the callback

         * @virtual

         */

        handler: function() {

},

        /**

         * bind the events

         */

        init: function() {

            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);

            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);

            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);

        },

        /**

         * unbind the events

         */

        destroy: function() {

            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);

            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);

            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);

        }

    };

    /**

     * create new input type manager

     * called by the Manager constructor

     * @param {Hammer} manager

     * @returns {Input}

     */

    function createInputInstance(manager) {

        var Type;

        var inputClass = manager.options.inputClass;

        if (inputClass) {

            Type = inputClass;

        } else if (SUPPORT_POINTER_EVENTS) {

            Type = PointerEventInput;

        } else if (SUPPORT_ONLY_TOUCH) {

            Type = TouchInput;

        } else if (!SUPPORT_TOUCH) {

            Type = MouseInput;

        } else {

            Type = TouchMouseInput;

        }

        return new(Type)(manager, inputHandler);

    }

    /**

     * handle input events

     * @param {Manager} manager

     * @param {String} eventType

     * @param {Object} input

     */

    function inputHandler(manager, eventType, input) {

        var pointersLen = input.pointers.length;

        var changedPointersLen = input.changedPointers.length;

        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));

        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

        input.isFirst = !!isFirst;

        input.isFinal = !!isFinal;

        if (isFirst) {

            manager.session = {};

        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);

        manager.recognize(input);

        manager.session.prevInput = input;

    }

    /**

     * extend the data with some usable properties like scale, rotate, velocity etc

     * @param {Object} manager

     * @param {Object} input

     */

    function computeInputData(manager, input) {

        var session = manager.session;

        var pointers = input.pointers;

        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {

            session.firstInput = simpleCloneInputData(input);

        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {

            session.firstMultiple = simpleCloneInputData(input);

        } else if (pointersLength === 1) {

            session.firstMultiple = false;

        }

        var firstInput = session.firstInput;

        var firstMultiple = session.firstMultiple;

        var offsetCenter = firstMultiple ? firstMultiple.center: firstInput.center;

        var center = input.center = getCenter(pointers);

        input.timeStamp = now();

        input.deltaTime = input.timeStamp - firstInput.timeStamp;

        input.angle = getAngle(offsetCenter, center);

        input.distance = getDistance(offsetCenter, center);

        computeDeltaXY(session, input);

        input.offsetDirection = getDirection(input.deltaX, input.deltaY);

        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;

        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;

        if (hasParent(input.srcEvent.target, target)) {

            target = input.srcEvent.target;

        }

        input.target = target;

    }

    function computeDeltaXY(session, input) {

        var center = input.center;

        var offset = session.offsetDelta || {};

        var prevDelta = session.prevDelta || {};

        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {

            prevDelta = session.prevDelta = {

                x: prevInput.deltaX || 0,

                y: prevInput.deltaY || 0

            };

            offset = session.offsetDelta = {

                x: center.x,

                y: center.y

            };

        }

        input.deltaX = prevDelta.x + (center.x - offset.x);

        input.deltaY = prevDelta.y + (center.y - offset.y);

    }

    /**

     * velocity is calculated every x ms

     * @param {Object} session

     * @param {Object} input

     */

    function computeIntervalInputData(session, input) {

        var last = session.lastInterval || input,

        deltaTime = input.timeStamp - last.timeStamp,

        velocity, velocityX, velocityY, direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {

            var deltaX = last.deltaX - input.deltaX;

            var deltaY = last.deltaY - input.deltaY;

            var v = getVelocity(deltaTime, deltaX, deltaY);

            velocityX = v.x;

            velocityY = v.y;

            velocity = (abs(v.x) > abs(v.y)) ? v.x: v.y;

            direction = getDirection(deltaX, deltaY);

            session.lastInterval = input;

        } else {

            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;

            velocityX = last.velocityX;

            velocityY = last.velocityY;

            direction = last.direction;

        }

        input.velocity = velocity;

        input.velocityX = velocityX;

        input.velocityY = velocityY;

        input.direction = direction;

    }

    /**

     * create a simple clone from the input used for storage of firstInput and firstMultiple

     * @param {Object} input

     * @returns {Object} clonedInputData

     */

    function simpleCloneInputData(input) {

        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];

        var i = 0;

        while (i < input.pointers.length) {

            pointers[i] = {

                clientX: round(input.pointers[i].clientX),

                clientY: round(input.pointers[i].clientY)

            };

            i++;

        }

        return {

            timeStamp: now(),

            pointers: pointers,

            center: getCenter(pointers),

            deltaX: input.deltaX,

            deltaY: input.deltaY

        };

    }

    /**

     * get the center of all the pointers

     * @param {Array} pointers

     * @return {Object} center contains `x` and `y` properties

     */

    function getCenter(pointers) {

        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {

            return {

                x: round(pointers[0].clientX),

                y: round(pointers[0].clientY)

            };

        }

        var x = 0,
        y = 0,
        i = 0;

        while (i < pointersLength) {

            x += pointers[i].clientX;

            y += pointers[i].clientY;

            i++;

        }

        return {

            x: round(x / pointersLength),

            y: round(y / pointersLength)

        };

    }

    /**

     * calculate the velocity between two points. unit is in px per ms.

     * @param {Number} deltaTime

     * @param {Number} x

     * @param {Number} y

     * @return {Object} velocity `x` and `y`

     */

    function getVelocity(deltaTime, x, y) {

        return {

            x: x / deltaTime || 0,

            y: y / deltaTime || 0

        };

    }

    /**

     * get the direction between two points

     * @param {Number} x

     * @param {Number} y

     * @return {Number} direction

     */

    function getDirection(x, y) {

        if (x === y) {

            return DIRECTION_NONE;

        }

        if (abs(x) >= abs(y)) {

            return x > 0 ? DIRECTION_LEFT: DIRECTION_RIGHT;

        }

        return y > 0 ? DIRECTION_UP: DIRECTION_DOWN;

    }

    /**

     * calculate the absolute distance between two points

     * @param {Object} p1 {x, y}

     * @param {Object} p2 {x, y}

     * @param {Array} [props] containing x and y keys

     * @return {Number} distance

     */

    function getDistance(p1, p2, props) {

        if (!props) {

            props = PROPS_XY;

        }

        var x = p2[props[0]] - p1[props[0]],

        y = p2[props[1]] - p1[props[1]];

        return Math.sqrt((x * x) + (y * y));

    }

    /**

     * calculate the angle between two coordinates

     * @param {Object} p1

     * @param {Object} p2

     * @param {Array} [props] containing x and y keys

     * @return {Number} angle

     */

    function getAngle(p1, p2, props) {

        if (!props) {

            props = PROPS_XY;

        }

        var x = p2[props[0]] - p1[props[0]],

        y = p2[props[1]] - p1[props[1]];

        return Math.atan2(y, x) * 180 / Math.PI;

    }

    /**

     * calculate the rotation degrees between two pointersets

     * @param {Array} start array of pointers

     * @param {Array} end array of pointers

     * @return {Number} rotation

     */

    function getRotation(start, end) {

        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);

    }

    /**

     * calculate the scale factor between two pointersets

     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out

     * @param {Array} start array of pointers

     * @param {Array} end array of pointers

     * @return {Number} scale

     */

    function getScale(start, end) {

        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);

    }

    var MOUSE_INPUT_MAP = {

        mousedown: INPUT_START,

        mousemove: INPUT_MOVE,

        mouseup: INPUT_END

    };

    var MOUSE_ELEMENT_EVENTS = 'mousedown';

    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

    /**

     * Mouse events input

     * @constructor

     * @extends Input

     */

    function MouseInput() {

        this.evEl = MOUSE_ELEMENT_EVENTS;

        this.evWin = MOUSE_WINDOW_EVENTS;

        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state

        Input.apply(this, arguments);

    }

    inherit(MouseInput, Input, {

        /**

         * handle mouse events

         * @param {Object} ev

         */

        handler: function MEhandler(ev) {

            var eventType = MOUSE_INPUT_MAP[ev.type];

            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) {

                this.pressed = true;

            }

            if (eventType & INPUT_MOVE && ev.which !== 1) {

                eventType = INPUT_END;

            }

            // mouse must be down, and mouse events are allowed (see the TouchMouse input)
            if (!this.pressed || !this.allow) {

                return;

            }

            if (eventType & INPUT_END) {

                this.pressed = false;

            }

            this.callback(this.manager, eventType, {

                pointers: [ev],

                changedPointers: [ev],

                pointerType: INPUT_TYPE_MOUSE,

                srcEvent: ev

            });

        }

    });

    var POINTER_INPUT_MAP = {

        pointerdown: INPUT_START,

        pointermove: INPUT_MOVE,

        pointerup: INPUT_END,

        pointercancel: INPUT_CANCEL,

        pointerout: INPUT_CANCEL

    };

    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {

        2 : INPUT_TYPE_TOUCH,

        3 : INPUT_TYPE_PEN,

        4 : INPUT_TYPE_MOUSE,

        5 : INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };

    var POINTER_ELEMENT_EVENTS = 'pointerdown';

    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

    // IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent) {

        POINTER_ELEMENT_EVENTS = 'MSPointerDown';

        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';

    }

    /**

     * Pointer events input

     * @constructor

     * @extends Input

     */

    function PointerEventInput() {

        this.evEl = POINTER_ELEMENT_EVENTS;

        this.evWin = POINTER_WINDOW_EVENTS;

        Input.apply(this, arguments);

        this.store = (this.manager.session.pointerEvents = []);

    }

    inherit(PointerEventInput, Input, {

        /**

         * handle mouse events

         * @param {Object} ev

         */

        handler: function PEhandler(ev) {

            var store = this.store;

            var removePointer = false;

            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');

            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];

            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

            var isTouch = (pointerType == INPUT_TYPE_TOUCH);

            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');

            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {

                if (storeIndex < 0) {

                    store.push(ev);

                    storeIndex = store.length - 1;

                }

            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {

                removePointer = true;

            }

            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) {

                return;

            }

            // update the event in the store
            store[storeIndex] = ev;

            this.callback(this.manager, eventType, {

                pointers: store,

                changedPointers: [ev],

                pointerType: pointerType,

                srcEvent: ev

            });

            if (removePointer) {

                // remove from the store
                store.splice(storeIndex, 1);

            }

        }

    });

    var SINGLE_TOUCH_INPUT_MAP = {

        touchstart: INPUT_START,

        touchmove: INPUT_MOVE,

        touchend: INPUT_END,

        touchcancel: INPUT_CANCEL

    };

    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';

    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**

     * Touch events input

     * @constructor

     * @extends Input

     */

    function SingleTouchInput() {

        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;

        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;

        this.started = false;

        Input.apply(this, arguments);

    }

    inherit(SingleTouchInput, Input, {

        handler: function TEhandler(ev) {

            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

            // should we handle the touch events?
            if (type === INPUT_START) {

                this.started = true;

            }

            if (!this.started) {

                return;

            }

            var touches = normalizeSingleTouches.call(this, ev, type);

            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {

                this.started = false;

            }

            this.callback(this.manager, type, {

                pointers: touches[0],

                changedPointers: touches[1],

                pointerType: INPUT_TYPE_TOUCH,

                srcEvent: ev

            });

        }

    });

    /**

     * @this {TouchInput}

     * @param {Object} ev

     * @param {Number} type flag

     * @returns {undefined|Array} [all, changed]

     */

    function normalizeSingleTouches(ev, type) {

        var all = toArray(ev.touches);

        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {

            all = uniqueArray(all.concat(changed), 'identifier', true);

        }

        return [all, changed];

    }

    var TOUCH_INPUT_MAP = {

        touchstart: INPUT_START,

        touchmove: INPUT_MOVE,

        touchend: INPUT_END,

        touchcancel: INPUT_CANCEL

    };

    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**

     * Multi-user touch events input

     * @constructor

     * @extends Input

     */

    function TouchInput() {

        this.evTarget = TOUCH_TARGET_EVENTS;

        this.targetIds = {};

        Input.apply(this, arguments);

    }

    inherit(TouchInput, Input, {

        handler: function MTEhandler(ev) {

            var type = TOUCH_INPUT_MAP[ev.type];

            var touches = getTouches.call(this, ev, type);

            if (!touches) {

                return;

            }

            this.callback(this.manager, type, {

                pointers: touches[0],

                changedPointers: touches[1],

                pointerType: INPUT_TYPE_TOUCH,

                srcEvent: ev

            });

        }

    });

    /**

     * @this {TouchInput}

     * @param {Object} ev

     * @param {Number} type flag

     * @returns {undefined|Array} [all, changed]

     */

    function getTouches(ev, type) {

        var allTouches = toArray(ev.touches);

        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {

            targetIds[allTouches[0].identifier] = true;

            return [allTouches, allTouches];

        }

        var i,

        targetTouches,

        changedTouches = toArray(ev.changedTouches),

        changedTargetTouches = [],

        target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {

            return hasParent(touch.target, target);

        });

        // collect touches
        if (type === INPUT_START) {

            i = 0;

            while (i < targetTouches.length) {

                targetIds[targetTouches[i].identifier] = true;

                i++;

            }

        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;

        while (i < changedTouches.length) {

            if (targetIds[changedTouches[i].identifier]) {

                changedTargetTouches.push(changedTouches[i]);

            }

            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {

                delete targetIds[changedTouches[i].identifier];

            }

            i++;

        }

        if (!changedTargetTouches.length) {

            return;

        }

        return [

        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),

        changedTargetTouches

        ];

    }

    /**

     * Combined touch and mouse input

     *

     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.

     * This because touch devices also emit mouse events while doing a touch.

     *

     * @constructor

     * @extends Input

     */

    function TouchMouseInput() {

        Input.apply(this, arguments);

        var handler = bindFn(this.handler, this);

        this.touch = new TouchInput(this.manager, handler);

        this.mouse = new MouseInput(this.manager, handler);

    }

    inherit(TouchMouseInput, Input, {

        /**

         * handle mouse and touch events

         * @param {Hammer} manager

         * @param {String} inputEvent

         * @param {Object} inputData

         */

        handler: function TMEhandler(manager, inputEvent, inputData) {

            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),

            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

            // when we're in a touch event, so  block all upcoming mouse events
            // most mobile browser also emit mouseevents, right after touchstart
            if (isTouch) {

                this.mouse.allow = false;

            } else if (isMouse && !this.mouse.allow) {

                return;

            }

            // reset the allowMouse when we're done
            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {

                this.mouse.allow = true;

            }

            this.callback(manager, inputEvent, inputData);

        },

        /**

         * remove the event listeners

         */

        destroy: function destroy() {

            this.touch.destroy();

            this.mouse.destroy();

        }

    });

    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');

    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';

    var TOUCH_ACTION_AUTO = 'auto';

    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';

    var TOUCH_ACTION_PAN_X = 'pan-x';

    var TOUCH_ACTION_PAN_Y = 'pan-y';

    /**

     * Touch Action

     * sets the touchAction property or uses the js alternative

     * @param {Manager} manager

     * @param {String} value

     * @constructor

     */

    function TouchAction(manager, value) {

        this.manager = manager;

        this.set(value);

    }

    TouchAction.prototype = {

        /**

         * set the touchAction value on the element or enable the polyfill

         * @param {String} value

         */

        set: function(value) {

            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {

                value = this.compute();

            }

            if (NATIVE_TOUCH_ACTION) {

                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;

            }

            this.actions = value.toLowerCase().trim();

        },

        /**

         * just re-set the touchAction value

         */

        update: function() {

            this.set(this.manager.options.touchAction);

        },

        /**

         * compute the value for the touchAction property based on the recognizer's settings

         * @returns {String} value

         */

        compute: function() {

            var actions = [];

            each(this.manager.recognizers,
            function(recognizer) {

                if (boolOrFn(recognizer.options.enable, [recognizer])) {

                    actions = actions.concat(recognizer.getTouchAction());

                }

            });

            return cleanTouchActions(actions.join(' '));

        },

        /**

         * this method is called on each input cycle and provides the preventing of the browser behavior

         * @param {Object} input

         */

        preventDefaults: function(input) {

            // not needed with native support for the touchAction property
            if (NATIVE_TOUCH_ACTION) {

                return;

            }

            var srcEvent = input.srcEvent;

            var direction = input.offsetDirection;

            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {

                srcEvent.preventDefault();

                return;

            }

            var actions = this.actions;

            var hasNone = inStr(actions, TOUCH_ACTION_NONE);

            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

            if (hasNone ||

            (hasPanY && direction & DIRECTION_HORIZONTAL) ||

            (hasPanX && direction & DIRECTION_VERTICAL)) {

                return this.preventSrc(srcEvent);

            }

        },

        /**

         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)

         * @param {Object} srcEvent

         */

        preventSrc: function(srcEvent) {

            this.manager.session.prevented = true;

            srcEvent.preventDefault();

        }

    };

    /**

     * when the touchActions are collected they are not a valid value, so we need to clean things up. *

     * @param {String} actions

     * @returns {*}

     */

    function cleanTouchActions(actions) {

        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {

            return TOUCH_ACTION_NONE;

        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // pan-x and pan-y can be combined
        if (hasPanX && hasPanY) {

            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;

        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {

            return hasPanX ? TOUCH_ACTION_PAN_X: TOUCH_ACTION_PAN_Y;

        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {

            return TOUCH_ACTION_MANIPULATION;

        }

        return TOUCH_ACTION_AUTO;

    }

    /**

     * Recognizer flow explained; *

     * All recognizers have the initial state of POSSIBLE when a input session starts.

     * The definition of a input session is from the first input until the last input, with all it's movement in it. *

     * Example session for mouse-input: mousedown -> mousemove -> mouseup

     *

     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed

     * which determines with state it should be.

     *

     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to

     * POSSIBLE to give it another change on the next cycle.

     *

     *               Possible

     *                  |

     *            +-----+---------------+

     *            |                     |

     *      +-----+-----+               |

     *      |           |               |

     *   Failed      Cancelled          |

     *                          +-------+------+

     *                          |              |

     *                      Recognized       Began

     *                                         |

     *                                      Changed

     *                                         |

     *                                  Ended/Recognized

     */

    var STATE_POSSIBLE = 1;

    var STATE_BEGAN = 2;

    var STATE_CHANGED = 4;

    var STATE_ENDED = 8;

    var STATE_RECOGNIZED = STATE_ENDED;

    var STATE_CANCELLED = 16;

    var STATE_FAILED = 32;

    /**

     * Recognizer

     * Every recognizer needs to extend from this class.

     * @constructor

     * @param {Object} options

     */

    function Recognizer(options) {

        this.id = uniqueId();

        this.manager = null;

        this.options = merge(options || {},
        this.defaults);

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);

        this.state = STATE_POSSIBLE;

        this.simultaneous = {};

        this.requireFail = [];

    }

    Recognizer.prototype = {

        /**

         * @virtual

         * @type {Object}

         */

        defaults: {},

        /**

         * set options

         * @param {Object} options

         * @return {Recognizer}

         */

        set: function(options) {

            extend(this.options, options);

            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();

            return this;

        },

        /**

         * recognize simultaneous with an other recognizer.

         * @param {Recognizer} otherRecognizer

         * @returns {Recognizer} this

         */

        recognizeWith: function(otherRecognizer) {

            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {

                return this;

            }

            var simultaneous = this.simultaneous;

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

            if (!simultaneous[otherRecognizer.id]) {

                simultaneous[otherRecognizer.id] = otherRecognizer;

                otherRecognizer.recognizeWith(this);

            }

            return this;

        },

        /**

         * drop the simultaneous link. it doesnt remove the link on the other recognizer.

         * @param {Recognizer} otherRecognizer

         * @returns {Recognizer} this

         */

        dropRecognizeWith: function(otherRecognizer) {

            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {

                return this;

            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

            delete this.simultaneous[otherRecognizer.id];

            return this;

        },

        /**

         * recognizer can only run when an other is failing

         * @param {Recognizer} otherRecognizer

         * @returns {Recognizer} this

         */

        requireFailure: function(otherRecognizer) {

            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {

                return this;

            }

            var requireFail = this.requireFail;

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

            if (inArray(requireFail, otherRecognizer) === -1) {

                requireFail.push(otherRecognizer);

                otherRecognizer.requireFailure(this);

            }

            return this;

        },

        /**

         * drop the requireFailure link. it does not remove the link on the other recognizer.

         * @param {Recognizer} otherRecognizer

         * @returns {Recognizer} this

         */

        dropRequireFailure: function(otherRecognizer) {

            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {

                return this;

            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

            var index = inArray(this.requireFail, otherRecognizer);

            if (index > -1) {

                this.requireFail.splice(index, 1);

            }

            return this;

        },

        /**

         * has require failures boolean

         * @returns {boolean}

         */

        hasRequireFailures: function() {

            return this.requireFail.length > 0;

        },

        /**

         * if the recognizer can recognize simultaneous with an other recognizer

         * @param {Recognizer} otherRecognizer

         * @returns {Boolean}

         */

        canRecognizeWith: function(otherRecognizer) {

            return !! this.simultaneous[otherRecognizer.id];

        },

        /**

         * You should use `tryEmit` instead of `emit` directly to check

         * that all the needed recognizers has failed before emitting.

         * @param {Object} input

         */

        emit: function(input) {

            var self = this;

            var state = this.state;

            function emit(withState) {

                self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);

            }

            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) {

                emit(true);

            }

            emit(); // simple 'eventName' events

            // panend and pancancel
            if (state >= STATE_ENDED) {

                emit(true);

            }

        },

        /**

         * Check that all the require failure recognizers has failed,

         * if true, it emits a gesture event,

         * otherwise, setup the state to FAILED.

         * @param {Object} input

         */

        tryEmit: function(input) {

            if (this.canEmit()) {

                return this.emit(input);

            }

            // it's failing anyway
            this.state = STATE_FAILED;

        },

        /**

         * can we emit?

         * @returns {boolean}

         */

        canEmit: function() {

            var i = 0;

            while (i < this.requireFail.length) {

                if (! (this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {

                    return false;

                }

                i++;

            }

            return true;

        },

        /**

         * update the recognizer

         * @param {Object} inputData

         */

        recognize: function(inputData) {

            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = extend({},
            inputData);

            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {

                this.reset();

                this.state = STATE_FAILED;

                return;

            }

            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {

                this.state = STATE_POSSIBLE;

            }

            this.state = this.process(inputDataClone);

            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {

                this.tryEmit(inputDataClone);

            }

        },

        /**

         * return the state of the recognizer

         * the actual recognizing happens in this method

         * @virtual

         * @param {Object} inputData

         * @returns {Const} STATE

         */

        process: function(inputData) {

},
        // jshint ignore:line

        /**

         * return the preferred touch-action

         * @virtual

         * @returns {Array}

         */

        getTouchAction: function() {

},

        /**

         * called when the gesture isn't allowed to recognize

         * like when another is being recognized or it is disabled

         * @virtual

         */

        reset: function() {

}

    };

    /**

     * get a usable string, used as event postfix

     * @param {Const} state

     * @returns {String} state

     */

    function stateStr(state) {

        if (state & STATE_CANCELLED) {

            return 'cancel';

        } else if (state & STATE_ENDED) {

            return 'end';

        } else if (state & STATE_CHANGED) {

            return 'move';

        } else if (state & STATE_BEGAN) {

            return 'start';

        }

        return '';

    }

    /**

     * direction cons to string

     * @param {Const} direction

     * @returns {String}

     */

    function directionStr(direction) {

        if (direction == DIRECTION_DOWN) {

            return 'down';

        } else if (direction == DIRECTION_UP) {

            return 'up';

        } else if (direction == DIRECTION_LEFT) {

            return 'left';

        } else if (direction == DIRECTION_RIGHT) {

            return 'right';

        }

        return '';

    }

    /**

     * get a recognizer by name if it is bound to a manager

     * @param {Recognizer|String} otherRecognizer

     * @param {Recognizer} recognizer

     * @returns {Recognizer}

     */

    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {

        var manager = recognizer.manager;

        if (manager) {

            return manager.get(otherRecognizer);

        }

        return otherRecognizer;

    }

    /**

     * This recognizer is just used as a base for the simple attribute recognizers.

     * @constructor

     * @extends Recognizer

     */

    function AttrRecognizer() {

        Recognizer.apply(this, arguments);

    }

    inherit(AttrRecognizer, Recognizer, {

        /**

         * @namespace

         * @memberof AttrRecognizer

         */

        defaults: {

            /**

             * @type {Number}

             * @default 1

             */

            pointers: 1

        },

        /**

         * Used to check if it the recognizer receives valid input, like input.distance > 10.

         * @memberof AttrRecognizer

         * @param {Object} input

         * @returns {Boolean} recognized

         */

        attrTest: function(input) {

            var optionPointers = this.options.pointers;

            return optionPointers === 0 || input.pointers.length === optionPointers;

        },

        /**

         * Process the input and return the state for the recognizer

         * @memberof AttrRecognizer

         * @param {Object} input

         * @returns {*} State

         */

        process: function(input) {

            var state = this.state;

            var eventType = input.eventType;

            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);

            var isValid = this.attrTest(input);

            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {

                return state | STATE_CANCELLED;

            } else if (isRecognized || isValid) {

                if (eventType & INPUT_END) {

                    return state | STATE_ENDED;

                } else if (! (state & STATE_BEGAN)) {

                    return STATE_BEGAN;

                }

                return state | STATE_CHANGED;

            }

            return STATE_FAILED;

        }

    });

    /**

     * Pan

     * Recognized when the pointer is down and moved in the allowed direction.

     * @constructor

     * @extends AttrRecognizer

     */

    function PanRecognizer() {

        AttrRecognizer.apply(this, arguments);

        this.pX = null;

        this.pY = null;

    }

    inherit(PanRecognizer, AttrRecognizer, {

        /**

         * @namespace

         * @memberof PanRecognizer

         */

        defaults: {

            event: 'pan',

            threshold: 10,

            pointers: 1,

            direction: DIRECTION_ALL

        },

        getTouchAction: function() {

            var direction = this.options.direction;

            var actions = [];

            if (direction & DIRECTION_HORIZONTAL) {

                actions.push(TOUCH_ACTION_PAN_Y);

            }

            if (direction & DIRECTION_VERTICAL) {

                actions.push(TOUCH_ACTION_PAN_X);

            }

            return actions;

        },

        directionTest: function(input) {

            var options = this.options;

            var hasMoved = true;

            var distance = input.distance;

            var direction = input.direction;

            var x = input.deltaX;

            var y = input.deltaY;

            // lock to axis?
            if (! (direction & options.direction)) {

                if (options.direction & DIRECTION_HORIZONTAL) {

                    direction = (x === 0) ? DIRECTION_NONE: (x < 0) ? DIRECTION_LEFT: DIRECTION_RIGHT;

                    hasMoved = x != this.pX;

                    distance = Math.abs(input.deltaX);

                } else {

                    direction = (y === 0) ? DIRECTION_NONE: (y < 0) ? DIRECTION_UP: DIRECTION_DOWN;

                    hasMoved = y != this.pY;

                    distance = Math.abs(input.deltaY);

                }

            }

            input.direction = direction;

            return hasMoved && distance > options.threshold && direction & options.direction;

        },

        attrTest: function(input) {

            return AttrRecognizer.prototype.attrTest.call(this, input) &&

            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));

        },

        emit: function(input) {

            this.pX = input.deltaX;

            this.pY = input.deltaY;

            var direction = directionStr(input.direction);

            if (direction) {

                this.manager.emit(this.options.event + direction, input);

            }

            this._super.emit.call(this, input);

        }

    });

    /**

     * Pinch

     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).

     * @constructor

     * @extends AttrRecognizer

     */

    function PinchRecognizer() {

        AttrRecognizer.apply(this, arguments);

    }

    inherit(PinchRecognizer, AttrRecognizer, {

        /**

         * @namespace

         * @memberof PinchRecognizer

         */

        defaults: {

            event: 'pinch',

            threshold: 0,

            pointers: 2

        },

        getTouchAction: function() {

            return [TOUCH_ACTION_NONE];

        },

        attrTest: function(input) {

            return this._super.attrTest.call(this, input) &&

            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);

        },

        emit: function(input) {

            this._super.emit.call(this, input);

            if (input.scale !== 1) {

                var inOut = input.scale < 1 ? 'in': 'out';

                this.manager.emit(this.options.event + inOut, input);

            }

        }

    });

    /**

     * Press

     * Recognized when the pointer is down for x ms without any movement.

     * @constructor

     * @extends Recognizer

     */

    function PressRecognizer() {

        Recognizer.apply(this, arguments);

        this._timer = null;

        this._input = null;

    }

    inherit(PressRecognizer, Recognizer, {

        /**

         * @namespace

         * @memberof PressRecognizer

         */

        defaults: {

            event: 'press',

            pointers: 1,

            time: 500,
            // minimal time of the pointer to be pressed
            threshold: 5 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function() {

            return [TOUCH_ACTION_AUTO];

        },

        process: function(input) {

            var options = this.options;

            var validPointers = input.pointers.length === options.pointers;

            var validMovement = input.distance < options.threshold;

            var validTime = input.deltaTime > options.time;

            this._input = input;

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {

                this.reset();

            } else if (input.eventType & INPUT_START) {

                this.reset();

                this._timer = setTimeoutContext(function() {

                    this.state = STATE_RECOGNIZED;

                    this.tryEmit();

                },
                options.time, this);

            } else if (input.eventType & INPUT_END) {

                return STATE_RECOGNIZED;

            }

            return STATE_FAILED;

        },

        reset: function() {

            clearTimeout(this._timer);

        },

        emit: function(input) {

            if (this.state !== STATE_RECOGNIZED) {

                return;

            }

            if (input && (input.eventType & INPUT_END)) {

                this.manager.emit(this.options.event + 'up', input);

            } else {

                this._input.timeStamp = now();

                this.manager.emit(this.options.event, this._input);

            }

        }

    });

    /**

     * Rotate

     * Recognized when two or more pointer are moving in a circular motion.

     * @constructor

     * @extends AttrRecognizer

     */

    function RotateRecognizer() {

        AttrRecognizer.apply(this, arguments);

    }

    inherit(RotateRecognizer, AttrRecognizer, {

        /**

         * @namespace

         * @memberof RotateRecognizer

         */

        defaults: {

            event: 'rotate',

            threshold: 0,

            pointers: 2

        },

        getTouchAction: function() {

            return [TOUCH_ACTION_NONE];

        },

        attrTest: function(input) {

            return this._super.attrTest.call(this, input) &&

            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);

        }

    });

    /**

     * Swipe

     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.

     * @constructor

     * @extends AttrRecognizer

     */

    function SwipeRecognizer() {

        AttrRecognizer.apply(this, arguments);

    }

    inherit(SwipeRecognizer, AttrRecognizer, {

        /**

         * @namespace

         * @memberof SwipeRecognizer

         */

        defaults: {

            event: 'swipe',

            threshold: 10,

            velocity: 0.65,

            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,

            pointers: 1

        },

        getTouchAction: function() {

            return PanRecognizer.prototype.getTouchAction.call(this);

        },

        attrTest: function(input) {

            var direction = this.options.direction;

            var velocity;

            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {

                velocity = input.velocity;

            } else if (direction & DIRECTION_HORIZONTAL) {

                velocity = input.velocityX;

            } else if (direction & DIRECTION_VERTICAL) {

                velocity = input.velocityY;

            }

            return this._super.attrTest.call(this, input) &&

            direction & input.direction &&

            input.distance > this.options.threshold &&

            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;

        },

        emit: function(input) {

            var direction = directionStr(input.direction);

            if (direction) {

                this.manager.emit(this.options.event + direction, input);

            }

            this.manager.emit(this.options.event, input);

        }

    });

    /**

     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur

     * between the given interval and position. The delay option can be used to recognize multi-taps without firing

     * a single tap.

     *

     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of

     * multi-taps being recognized.

     * @constructor

     * @extends Recognizer

     */

    function TapRecognizer() {

        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;

        this.pCenter = false;

        this._timer = null;

        this._input = null;

        this.count = 0;

    }

    inherit(TapRecognizer, Recognizer, {

        /**

         * @namespace

         * @memberof PinchRecognizer

         */

        defaults: {

            event: 'tap',

            pointers: 1,

            taps: 1,

            interval: 300,
            // max time between the multi-tap taps
            time: 250,
            // max time of the pointer to be down (like finger on the screen)
            threshold: 2,
            // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function() {

            return [TOUCH_ACTION_MANIPULATION];

        },

        process: function(input) {

            var options = this.options;

            var validPointers = input.pointers.length === options.pointers;

            var validMovement = input.distance < options.threshold;

            var validTouchTime = input.deltaTime < options.time;

            this.reset();

            if ((input.eventType & INPUT_START) && (this.count === 0)) {

                return this.failTimeout();

            }

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {

                if (input.eventType != INPUT_END) {

                    return this.failTimeout();

                }

                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;

                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                this.pTime = input.timeStamp;

                this.pCenter = input.center;

                if (!validMultiTap || !validInterval) {

                    this.count = 1;

                } else {

                    this.count += 1;

                }

                this._input = input;

                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;

                if (tapCount === 0) {

                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) {

                        return STATE_RECOGNIZED;

                    } else {

                        this._timer = setTimeoutContext(function() {

                            this.state = STATE_RECOGNIZED;

                            this.tryEmit();

                        },
                        options.interval, this);

                        return STATE_BEGAN;

                    }

                }

            }

            return STATE_FAILED;

        },

        failTimeout: function() {

            this._timer = setTimeoutContext(function() {

                this.state = STATE_FAILED;

            },
            this.options.interval, this);

            return STATE_FAILED;

        },

        reset: function() {

            clearTimeout(this._timer);

        },

        emit: function() {

            if (this.state == STATE_RECOGNIZED) {

                this._input.tapCount = this.count;

                this.manager.emit(this.options.event, this._input);

            }

        }

    });

    /**

     * Simple way to create an manager with a default set of recognizers.

     * @param {HTMLElement} element

     * @param {Object} [options]

     * @constructor

     */

    function Hammer(element, options) {

        options = options || {};

        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);

        return new Manager(element, options);

    }

    /**

     * @const {string}

     */

    Hammer.VERSION = '2.0.4';

    /**

     * default settings

     * @namespace

     */

    Hammer.defaults = {

        /**

         * set if DOM events are being triggered.

         * But this is slower and unused by simple implementations, so disabled by default.

         * @type {Boolean}

         * @default false

         */

        domEvents: false,

        /**

         * The value for the touchAction property/fallback.

         * When set to `compute` it will magically set the correct value based on the added recognizers.

         * @type {String}

         * @default compute

         */

        touchAction: TOUCH_ACTION_COMPUTE,

        /**

         * @type {Boolean}

         * @default true

         */

        enable: true,

        /**

         * EXPERIMENTAL FEATURE -- can be removed/changed

         * Change the parent input target element.

         * If Null, then it is being set the to main element.

         * @type {Null|EventTarget}

         * @default null

         */

        inputTarget: null,

        /**

         * force an input class

         * @type {Null|Function}

         * @default null

         */

        inputClass: null,

        /**

         * Default recognizer setup when calling `Hammer()`

         * When creating a new Manager these will be skipped.

         * @type {Array}

         */

        preset: [

        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {
            enable: false
        }],

        [PinchRecognizer, {
            enable: false
        },
        ['rotate']],

        [SwipeRecognizer, {
            direction: DIRECTION_HORIZONTAL
        }],

        [PanRecognizer, {
            direction: DIRECTION_HORIZONTAL
        },
        ['swipe']],

        [TapRecognizer],

        [TapRecognizer, {
            event: 'doubletap',
            taps: 2
        },
        ['tap']],

        [PressRecognizer]

        ],

        /**

         * Some CSS properties can be used to improve the working of Hammer.

         * Add them to this method and they will be set when creating a new Manager.

         * @namespace

         */

        cssProps: {

            /**

             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.

             * @type {String}

             * @default 'none'

             */

            userSelect: 'none',

            /**

             * Disable the Windows Phone grippers when pressing an element.

             * @type {String}

             * @default 'none'

             */

            touchSelect: 'none',

            /**

             * Disables the default callout shown when you touch and hold a touch target.

             * On iOS, when you touch and hold a touch target such as a link, Safari displays

             * a callout containing information about the link. This property allows you to disable that callout.

             * @type {String}

             * @default 'none'

             */

            touchCallout: 'none',

            /**

             * Specifies whether zooming is enabled. Used by IE10>

             * @type {String}

             * @default 'none'

             */

            contentZooming: 'none',

            /**

             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.

             * @type {String}

             * @default 'none'

             */

            userDrag: 'none',

            /**

             * Overrides the highlight color shown when the user taps a link or a JavaScript

             * clickable element in iOS. This property obeys the alpha value, if specified.

             * @type {String}

             * @default 'rgba(0,0,0,0)'

             */

            tapHighlightColor: 'rgba(0,0,0,0)'

        }

    };

    var STOP = 1;

    var FORCED_STOP = 2;

    /**

     * Manager

     * @param {HTMLElement} element

     * @param {Object} [options]

     * @constructor

     */

    function Manager(element, options) {

        options = options || {};

        this.options = merge(options, Hammer.defaults);

        this.options.inputTarget = this.options.inputTarget || element;

        this.handlers = {};

        this.session = {};

        this.recognizers = [];

        this.element = element;

        this.input = createInputInstance(this);

        this.touchAction = new TouchAction(this, this.options.touchAction);

        toggleCssProps(this, true);

        each(options.recognizers,
        function(item) {

            var recognizer = this.add(new(item[0])(item[1]));

            item[2] && recognizer.recognizeWith(item[2]);

            item[3] && recognizer.requireFailure(item[3]);

        },
        this);

    }

    Manager.prototype = {

        /**

         * set options

         * @param {Object} options

         * @returns {Manager}

         */

        set: function(options) {

            extend(this.options, options);

            // Options that need a little more setup
            if (options.touchAction) {

                this.touchAction.update();

            }

            if (options.inputTarget) {

                // Clean up existing event listeners and reinitialize
                this.input.destroy();

                this.input.target = options.inputTarget;

                this.input.init();

            }

            return this;

        },

        /**

         * stop recognizing for this session.

         * This session will be discarded, when a new [input]start event is fired.

         * When forced, the recognizer cycle is stopped immediately.

         * @param {Boolean} [force]

         */

        stop: function(force) {

            this.session.stopped = force ? FORCED_STOP: STOP;

        },

        /**

         * run the recognizers!

         * called by the inputHandler function on every movement of the pointers (touches)

         * it walks through all the recognizers and tries to detect the gesture that is being made

         * @param {Object} inputData

         */

        recognize: function(inputData) {

            var session = this.session;

            if (session.stopped) {

                return;

            }

            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);

            var recognizer;

            var recognizers = this.recognizers;

            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;

            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {

                curRecognizer = session.curRecognizer = null;

            }

            var i = 0;

            while (i < recognizers.length) {

                recognizer = recognizers[i];

                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && ( // 1
                ! curRecognizer || recognizer == curRecognizer || // 2
                recognizer.canRecognizeWith(curRecognizer))) { // 3
                    recognizer.recognize(inputData);

                } else {

                    recognizer.reset();

                }

                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {

                    curRecognizer = session.curRecognizer = recognizer;

                }

                i++;

            }

        },

        /**

         * get a recognizer by its event name.

         * @param {Recognizer|String} recognizer

         * @returns {Recognizer|Null}

         */

        get: function(recognizer) {

            if (recognizer instanceof Recognizer) {

                return recognizer;

            }

            var recognizers = this.recognizers;

            for (var i = 0; i < recognizers.length; i++) {

                if (recognizers[i].options.event == recognizer) {

                    return recognizers[i];

                }

            }

            return null;

        },

        /**

         * add a recognizer to the manager

         * existing recognizers with the same event name will be removed

         * @param {Recognizer} recognizer

         * @returns {Recognizer|Manager}

         */

        add: function(recognizer) {

            if (invokeArrayArg(recognizer, 'add', this)) {

                return this;

            }

            // remove existing
            var existing = this.get(recognizer.options.event);

            if (existing) {

                this.remove(existing);

            }

            this.recognizers.push(recognizer);

            recognizer.manager = this;

            this.touchAction.update();

            return recognizer;

        },

        /**

         * remove a recognizer by name or instance

         * @param {Recognizer|String} recognizer

         * @returns {Manager}

         */

        remove: function(recognizer) {

            if (invokeArrayArg(recognizer, 'remove', this)) {

                return this;

            }

            var recognizers = this.recognizers;

            recognizer = this.get(recognizer);

            recognizers.splice(inArray(recognizers, recognizer), 1);

            this.touchAction.update();

            return this;

        },

        /**

         * bind event

         * @param {String} events

         * @param {Function} handler

         * @returns {EventEmitter} this

         */

        on: function(events, handler) {

            var handlers = this.handlers;

            each(splitStr(events),
            function(event) {

                handlers[event] = handlers[event] || [];

                handlers[event].push(handler);

            });

            return this;

        },

        /**

         * unbind event, leave emit blank to remove all handlers

         * @param {String} events

         * @param {Function} [handler]

         * @returns {EventEmitter} this

         */

        off: function(events, handler) {

            var handlers = this.handlers;

            each(splitStr(events),
            function(event) {

                if (!handler) {

                    delete handlers[event];

                } else {

                    handlers[event].splice(inArray(handlers[event], handler), 1);

                }

            });

            return this;

        },

        /**

         * emit event to the listeners

         * @param {String} event

         * @param {Object} data

         */

        emit: function(event, data) {

            // we also want to trigger dom events
            if (this.options.domEvents) {

                triggerDomEvent(event, data);

            }

            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();

            if (!handlers || !handlers.length) {

                return;

            }

            data.type = event;

            data.preventDefault = function() {

                data.srcEvent.preventDefault();

            };

            var i = 0;

            while (i < handlers.length) {

                handlers[i](data);

                i++;

            }

        },

        /**

         * destroy the manager and unbinds all events

         * it doesn't unbind dom events, that is the user own responsibility

         */

        destroy: function() {

            this.element && toggleCssProps(this, false);

            this.handlers = {};

            this.session = {};

            this.input.destroy();

            this.element = null;

        }

    };

    /**

     * add/remove the css properties as defined in manager.options.cssProps

     * @param {Manager} manager

     * @param {Boolean} add

     */

    function toggleCssProps(manager, add) {

        var element = manager.element;

        each(manager.options.cssProps,
        function(value, name) {

            element.style[prefixed(element.style, name)] = add ? value: '';

        });

    }

    /**

     * trigger dom event

     * @param {String} event

     * @param {Object} data

     */

    function triggerDomEvent(event, data) {

        var gestureEvent = document.createEvent('Event');

        gestureEvent.initEvent(event, true, true);

        gestureEvent.gesture = data;

        data.target.dispatchEvent(gestureEvent);

    }

    extend(Hammer, {

        INPUT_START: INPUT_START,

        INPUT_MOVE: INPUT_MOVE,

        INPUT_END: INPUT_END,

        INPUT_CANCEL: INPUT_CANCEL,

        STATE_POSSIBLE: STATE_POSSIBLE,

        STATE_BEGAN: STATE_BEGAN,

        STATE_CHANGED: STATE_CHANGED,

        STATE_ENDED: STATE_ENDED,

        STATE_RECOGNIZED: STATE_RECOGNIZED,

        STATE_CANCELLED: STATE_CANCELLED,

        STATE_FAILED: STATE_FAILED,

        DIRECTION_NONE: DIRECTION_NONE,

        DIRECTION_LEFT: DIRECTION_LEFT,

        DIRECTION_RIGHT: DIRECTION_RIGHT,

        DIRECTION_UP: DIRECTION_UP,

        DIRECTION_DOWN: DIRECTION_DOWN,

        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,

        DIRECTION_VERTICAL: DIRECTION_VERTICAL,

        DIRECTION_ALL: DIRECTION_ALL,

        Manager: Manager,

        Input: Input,

        TouchAction: TouchAction,

        TouchInput: TouchInput,

        MouseInput: MouseInput,

        PointerEventInput: PointerEventInput,

        TouchMouseInput: TouchMouseInput,

        SingleTouchInput: SingleTouchInput,

        Recognizer: Recognizer,

        AttrRecognizer: AttrRecognizer,

        Tap: TapRecognizer,

        Pan: PanRecognizer,

        Swipe: SwipeRecognizer,

        Pinch: PinchRecognizer,

        Rotate: RotateRecognizer,

        Press: PressRecognizer,

        on: addEventListeners,

        off: removeEventListeners,

        each: each,

        merge: merge,

        extend: extend,

        inherit: inherit,

        bindFn: bindFn,

        prefixed: prefixed

    });

    if (typeof define == TYPE_FUNCTION && define.amd) {

        define(function() {

            return Hammer;

        });

    } else if (typeof module != 'undefined' && module.exports) {

        module.exports = Hammer;

    } else {

        window[exportName] = Hammer;

    }

})(window, document, 'Hammer');

/* jquery.hammer.js */

(function(factory) {

    if (typeof define === 'function' && define.amd) {

        define(['jquery', 'hammerjs'], factory);

    } else if (typeof exports === 'object') {

        factory(require('jquery'), require('hammerjs'));

    } else {

        factory(jQuery, Hammer);

    }

} (function($, Hammer) {

    function hammerify(el, options) {

        var $el = $(el);

        if (!$el.data("hammer")) {

            $el.data("hammer", new Hammer($el[0], options));

        }

    }

    $.fn.hammer = function(options) {

        return this.each(function() {

            hammerify(this, options);

        });

    };

    // extend the emit method to also trigger jQuery events
    Hammer.Manager.prototype.emit = (function(originalEmit) {

        return function(type, data) {

            originalEmit.call(this, type, data);

            $(this.element).trigger({

                type: type,

                gesture: data

            });

        };

    })(Hammer.Manager.prototype.emit);

}));